import type { PayoffMatrix, EquilibriumPosition, Action } from '@/types'

const ACTIONS: Action[] = ['cooperate', 'defect']

/**
 * Calculate social welfare (sum of both players' payoffs) for each cell.
 *
 * Social welfare represents the total utility generated by an outcome.
 * Higher social welfare indicates a more efficient outcome.
 */
export function calculateSocialWelfare(matrix: PayoffMatrix): Map<string, number> {
  const welfare = new Map<string, number>()

  for (const rowAction of ACTIONS) {
    for (const colAction of ACTIONS) {
      const payoffs = matrix[rowAction][colAction]
      const sum = payoffs[0] + payoffs[1]
      welfare.set(`${rowAction}-${colAction}`, sum)
    }
  }

  return welfare
}

/**
 * Find the outcome with maximum social welfare.
 */
export function findMaxSocialWelfare(matrix: PayoffMatrix): {
  position: EquilibriumPosition
  welfare: number
} {
  let maxWelfare = -Infinity
  let maxPosition: EquilibriumPosition = { row: 'cooperate', col: 'cooperate' }

  for (const rowAction of ACTIONS) {
    for (const colAction of ACTIONS) {
      const payoffs = matrix[rowAction][colAction]
      const welfare = payoffs[0] + payoffs[1]

      if (welfare > maxWelfare) {
        maxWelfare = welfare
        maxPosition = { row: rowAction, col: colAction }
      }
    }
  }

  return { position: maxPosition, welfare: maxWelfare }
}

/**
 * Find Pareto optimal outcomes.
 *
 * An outcome is Pareto optimal if there is no other outcome where at least
 * one player is better off and no player is worse off.
 *
 * Formally: Outcome (s_A, s_B) is Pareto optimal if there's no (s_A', s_B')
 * where U_i(s_A', s_B') >= U_i(s_A, s_B) for all i, with strict inequality for some i.
 */
export function findParetoOptimal(matrix: PayoffMatrix): EquilibriumPosition[] {
  interface Outcome {
    row: Action
    col: Action
    payoffA: number
    payoffB: number
  }

  const outcomes: Outcome[] = []

  for (const row of ACTIONS) {
    for (const col of ACTIONS) {
      const [payoffA, payoffB] = matrix[row][col]
      outcomes.push({ row, col, payoffA, payoffB })
    }
  }

  // Filter to only Pareto optimal outcomes
  return outcomes
    .filter((outcome) => {
      // Check if any other outcome Pareto dominates this one
      const isDominated = outcomes.some(
        (other) =>
          // At least as good for both players
          other.payoffA >= outcome.payoffA &&
          other.payoffB >= outcome.payoffB &&
          // Strictly better for at least one player
          (other.payoffA > outcome.payoffA || other.payoffB > outcome.payoffB)
      )
      return !isDominated
    })
    .map((o) => ({ row: o.row, col: o.col }))
}

/**
 * Check if a specific outcome is Pareto optimal.
 */
export function isParetoOptimal(
  matrix: PayoffMatrix,
  row: Action,
  col: Action
): boolean {
  const paretoOptimal = findParetoOptimal(matrix)
  return paretoOptimal.some((pos) => pos.row === row && pos.col === col)
}
